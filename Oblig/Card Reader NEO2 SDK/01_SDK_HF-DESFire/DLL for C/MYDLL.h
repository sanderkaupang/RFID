#ifndef LIB_H
#define LIB_H

//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																									  说明
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
//所有数据都为16进制数据（HEX），程序编写注意与其他数据类型的转换
//--------------------------------------------------------------------------------------------------------
//注意C#和java里面的数据类型与C/C++不同，比如C语言里面的unsigned char可能是C#/Java里面的Byte，注意引用区别：
//C++:int PiccAuthKey(unsigned char auth_mode,unsigned char addr,unsigned char *pSnr,unsigned char *pKey);
//C#: int PiccAuthKey(byte auth_mode,byte addr,byte[] pSnr,byte[] pKey);
//--------------------------------------------------------------------------------------------------------
//C++调用MYDLL.dll的同时可能会用到MYDLL.lib文件，需要#pragma comment(lib, "MYDLL.lib")
//C# 调用MYDLL.dll的时候需要[DllImport("MYDLL.dll")]




//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																								  错误代码
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
#define OK				0x00
#define FAIL			0x01
#define WRITECOMMFAIL	0x02
#define READCOMMFAIL	0x03
#define READTIMEOUT		0x04
#define FORMATWRONG		0x05 



//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																			串口操作函数/USB CDC设备类操作
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
/*
//--------------------------------------------------------------------------------------------------------
//校验函数，len为需要校验数据的长度（包括校验本身），buff为需要校验的数据（包括校验本身）
//此函数串口通信时内部使用，校验结果为buff的len长度内的最后一个字节
//--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int LRC(unsigned short int len,char *buff);

/*
//--------------------------------------------------------------------------------------------------------
//打开串口，port需要根据读卡器连接的串口号而定，一般计算机的第一个串口号为1，以此类推。
//baundrate为串口通信的速度，读卡器默认速度为115200，所以baundrate需要输入115200的整形
//返回0表示成功，其他为失败，失败的原因一般分两种，一种是计算机没有此串口号的串口，另外一种
//原因是串口已经被打开，此时可以先做一次关闭操作再尝试打开。
//--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int open(int port,long baundrate);

/*
//--------------------------------------------------------------------------------------------------------
//关闭串口，串口一旦被打开，就不能再次打开，除非做关闭操作
//--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int close(void);

/*
//--------------------------------------------------------------------------------------------------------
//此函数用于更改已经打开了的串口的通信速度，一般情况可以不使用
//--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int baud(long baundrate);

/*
//--------------------------------------------------------------------------------------------------------
//设置串口超时时间，不设置的话默认1000ms，单位为ms，可以不使用
//--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int timeout(int time);


//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																						   USB HID操作函数
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------
//打开USB接口，需要输入USB设备id，serial_number可使用NULL，默认使用方法为openhid(0x0483,0x5750,NULL);
//--------------------------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) int openhid(unsigned short vendor_id, unsigned short product_id, wchar_t *serial_number);

//--------------------------------------------------------------------------------------------------------
//关闭之前打开的USB HID设备
//--------------------------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) int closehid(void);


//--------------------------------------------------------------------------------------------------------
//读卡器声光控制和功能设置，可以不使用
//--------------------------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) int SetBuzzer(unsigned char ucRates,unsigned char ucTimes) ;
extern "C" __declspec(dllexport) int SetLed(unsigned char ucRates,unsigned char ucTimes) ;
extern "C" __declspec(dllexport) int SetUARTBaudRate(unsigned char ucRates) ;


//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																	  ISO 14443A卡操作函数，包括mifare卡片
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccAuthKey用于认证已经激活或选择的mifare one卡片
--------------------------------------------------------------------------------------------------------
2.auth_mode为认证模式，0x60表示密码A，0x61表示密码B
3.addr为卡片块号码，从0开始，同一个扇区内的任何块一旦认证其他块都可以操作
4.*pSnr为卡片卡号，4个字节，假如是7字节卡片，请输入后面四个字节卡号
5.*pKey为卡片密码，6个字节，新卡默认为0xff，0xff，0xff，0xff，0xff，0xff
--------------------------------------------------------------------------------------------------------
6.执行成功PiccAuthKey返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccAuthKey(	unsigned char auth_mode,
													unsigned char addr,
													unsigned char *pSnr,
													unsigned char *pKey) ;

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccRead用于读取已经认证成功的mifare one卡片的块数据
--------------------------------------------------------------------------------------------------------
2.ucBlock为要操作的块号码，从0开始
3.*pBuf为返回的块数据，固定为16字节
--------------------------------------------------------------------------------------------------------
4.执行成功PiccRead返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccRead(unsigned char ucBlock, unsigned char *pBuf);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccWrite用于写入已经认证成功的mifare one卡片的块数据
--------------------------------------------------------------------------------------------------------
2.ucBlock为要操作的块号码，从0开始
3.*pBuf为输入的块数据，固定为16字节
--------------------------------------------------------------------------------------------------------
4.执行成功PiccWrite返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccWrite(unsigned char ucBlock,unsigned char *pBuf);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccITGRead用于集成快速的读取mifare one卡扇区数据，一条命令集成了寻卡，选卡，认证，读卡的功能
--------------------------------------------------------------------------------------------------------
2.rst_ms为是否复位天线，复位的时间，一般取10，即0x0A，单位为毫秒
3.req_mode为寻卡模式，默认输入为0x52 All模式，也可输入0x26 idle模式
4.sector_begin为操作的扇区（sector）号，注意与块号（block）的区别，对于mifare 1k卡片一个扇区里面有4个块
5.sector_much为一次要操作的扇区数目，从sector_begin开始算起，一次最多操作4个扇区，操作多扇区时不同扇区的密码必须一致
6.block_each为一个扇区里面操作多少个块，靠前取，比如block_each==3，则每个扇区的前3个块会被读出
7.auth_mode为认证模式，0x60表示密码A，0x61表示密码B
8.*pKey为卡片密码，6个字节，新卡默认为0xff，0xff，0xff，0xff，0xff，0xff
9.*pBuf为返回的数据，用户需要根据之前的参数判断此数据包的数据组成顺序
--------------------------------------------------------------------------------------------------------
10.执行成功PiccITGRead返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
注意：
PiccITGRead命令集成了PiccActivateA + PiccAuthKey + PiccRead的功能，注意一次只能操作一张卡片
一次最多操作4个扇区获取最多256字节数据，连续操作几个扇区注意这几个扇区的密码必须一致
block_each为0x03时表示不操作此扇区的密码块，为0x04时所有块都会读出
举例：
sector_begin==0；sector_much==4；block_each==3；意思是从第0扇区开始读4个扇区，取每个扇区的前3个块输出
sector_begin==0；sector_much==1；block_each==4；意思是从第0扇区开始读1个扇区，整个扇区的4个块都输出
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccITGRead(	unsigned char rst_ms,
													unsigned char req_mode,
													unsigned char sector_begin,
													unsigned char sector_much,
													unsigned char block_each,
													unsigned char auth_mode,
													unsigned char *pKey,
													unsigned char *pBuf);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccITGWrite用于集成快速的写入mifare one卡扇区数据，一条命令集成了寻卡，选卡，认证，写卡的功能
--------------------------------------------------------------------------------------------------------
2.rst_ms为是否复位天线，复位的时间，一般取10，即0x0A，单位为毫秒
3.req_mode为寻卡模式，默认输入为0x52 All模式，也可输入0x26 idle模式
4.sector_begin为操作的扇区（sector）号，注意与块号（block）的区别，对于mifare 1k卡片一个扇区里面有4个块
5.sector_much为一次要操作的扇区数目，从sector_begin开始算起，一次最多操作4个扇区，操作多扇区时不同扇区的密码必须一致
6.block_each为一个扇区里面操作多少个块，靠前取，比如block_each==3，则每个扇区的前3个块会被读出
7.auth_mode为认证模式，0x60表示密码A，0x61表示密码B
8.*pKey为卡片密码，6个字节，新卡默认为0xff，0xff，0xff，0xff，0xff，0xff
9.*pBuf为要写入的数据，用户需要根据之前的参数组织好此数据包的数据组成顺序
--------------------------------------------------------------------------------------------------------
10.执行成功PiccITGWrite返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
注意：
PiccITGWrite命令集成了PiccActivateA + PiccAuthKey + PiccWrite的功能，注意一次只能操作一张卡片
一次最多操作4个扇区写入最多256字节数据，连续操作几个扇区注意这几个扇区的密码必须一致
block_each为0x03时表示不操作此扇区的密码块，为0x04时所有块都会写入，由于第4块是密码块，容易改写密码，注意！
举例：
sector_begin==0；sector_much==4；block_each==3；意思是从第0扇区开始写4个扇区，写入每个扇区的前3个块
sector_begin==0；sector_much==1；block_each==4；意思是从第0扇区开始写1个扇区，整个扇区的4个块都写入
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccITGWrite(	unsigned char rst_ms,
													unsigned char req_mode,
													unsigned char sector_begin,
													unsigned char sector_much,
													unsigned char block_each,
													unsigned char auth_mode,
													unsigned char *pKey,
													unsigned char *pBuf);
/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccULWrite用于写入mifare ultralight卡片的块数据
--------------------------------------------------------------------------------------------------------
2.ucBlock为要操作的块号码，从0开始
3.*pBuf为输入的块数据，固定为4字节
--------------------------------------------------------------------------------------------------------
4.执行成功PiccULWrite返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccULWrite(unsigned char ucBlock,unsigned char *pBuf);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccInitVL用于初始化已经认证成功的mifare one卡片的块电子钱包
--------------------------------------------------------------------------------------------------------
2.ucBlock为要操作的块号码，从0开始
3.*pBuf为输入的金额，4个字节，低字节在前，比如0x64，0x00，0x00，0x00表示100个单位的电子钱包额度
--------------------------------------------------------------------------------------------------------
4.执行成功PiccInitVL返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccInitVL(unsigned char ucBlock,unsigned char *pBuf);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccValueOper用于增值/减值电子钱包操作
--------------------------------------------------------------------------------------------------------
2.ucOperMode:0xC0表示对电子钱包减值，0xC1表示对电子钱包加值
3.ucBlock为要操作的块号码，从0开始
4.*pBuf为输入的金额，4个字节，低字节在前，比如0x01，0x00，0x00，0x00表示1个单位的电子钱包额度
--------------------------------------------------------------------------------------------------------
5.执行成功PiccValueOper返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccValueOper(	unsigned char ucOperMode, 
													unsigned char ucBlock,
													unsigned char *pValue, 
													unsigned char ucTransBlock);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccBackup用于把电子钱包备份到同扇区的另外一个块上
--------------------------------------------------------------------------------------------------------
2.ucBlock为要操作的块号码(需要备份的块)，从0开始
3.ucTransBlock为备份到的目的块
--------------------------------------------------------------------------------------------------------
4.执行成功PiccBackup返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccBackup(	unsigned char ucBlock,
													unsigned char ucTransBlock);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccReadValue用于读出电子钱包的额度
--------------------------------------------------------------------------------------------------------
2.ucBlock为要操作的块号码，从0开始
3.*pBuf为读出的金额，4个字节，低字节在前，比如0x64，0x00，0x00，0x00表示100个单位的电子钱包额度
--------------------------------------------------------------------------------------------------------
4.执行成功PiccReadValue返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccReadValue(unsigned char ucBlock, unsigned char *pBuf);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccReset用于复位天线或者说复位卡片
--------------------------------------------------------------------------------------------------------
2._1ms为要关闭电场的时间，单位为毫秒，假如输入参数为0x00，表示一直关闭，可以省电
--------------------------------------------------------------------------------------------------------
3.执行成功PiccReset返回0，失败则为其它
*/
extern "C" __declspec(dllexport) int PiccReset(unsigned char _1ms);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccActivateA用于作寻卡操作，目的是取得当前天线区域内的某张ISO14443 A协议卡片卡号
--------------------------------------------------------------------------------------------------------
2.ucMode在寻卡时是否附带关闭打开天线功能，与PiccReset函数里面的_1ms的定义一致
3.ucReqCode一般使用0x52
4.*pATQ为返回的请求应答(Answer To Request)，两个字节，可以用于判断卡类型，比如mifare one卡一般是0x04，0x00
5.*pSAK为选卡应答(Select AcKnowledge)，一个字节，可以用于判断是否CPU卡，与上0x20为非0的即为CPU类型卡
6.*pUIDLen为返回卡号长度，一般为0x04或者0x07
7.*pUID为返回卡号，可能4字节也可能7字节
--------------------------------------------------------------------------------------------------------
8.执行成功PiccActivateA返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
注意：此命令集成了寻卡，防冲突，选卡的过程，
假如是ultralight卡片，后续命令是读写操作
假如是mifare one卡，后续命令应该是PiccAuthKey认证卡片密码，然后读写或者电子钱包操作
假如是CPU卡，后续命令应该是PiccRequestATS请求应答，把卡片置位ISO14443-4 T=CL模式，然后PiccTPCL发送APDU
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccActivateA(	unsigned char ucMode, 
													unsigned char ucReqCode, 
													unsigned char *pATQ, 
													unsigned char *pSAK,
													unsigned char *pUIDLen,       
													unsigned char *pUID     );

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccADRcv用于自动寻卡功能，一般用于嵌入式系统串口读卡器使用
--------------------------------------------------------------------------------------------------------
2.ucMode为模式，默认为0x00
3.ucReqTime为寻卡时间间隔，默认为100ms，即0x64；或者200ms，即0xC8
--------------------------------------------------------------------------------------------------------
3.执行成功PiccADRcv返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
注意：
此函数执行成功后即进入自动寻卡模式，有卡的话直接返回卡片信息，返回信息的数据格式与PiccActivateA一致
此函数一般嵌入式系统串口读卡模块使用，使用时配合通信协议
发送任何其他命令将自动退出自动寻卡模式
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccADRcv( unsigned char ucMode,unsigned char ucReqTime);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccActivateB用于作寻卡操作，目的是取得当前天线区域内的某张ISO14443 B协议卡片卡号
--------------------------------------------------------------------------------------------------------
2.ucMode在寻卡时是否附带关闭打开天线功能，与PiccReset函数里面的_1ms的定义一致
3.ucAFI一般使用0x00
4.ucMethod一般使用0x01
5.*pUIDLen为返回卡号长度
6.*pUID为返回卡号和应答信息
--------------------------------------------------------------------------------------------------------
7.执行成功PiccActivateB返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccActivateB(	unsigned char ucMode, 
													unsigned char ucAFI, 
													unsigned char ucMethod,
													unsigned char *pUIDLen,
													unsigned char *pUID);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccActivateC用于作寻卡操作，目的是取得当前天线区域内的某张SONY Felica协议卡片卡号
--------------------------------------------------------------------------------------------------------
2.ucMode在寻卡时是否附带关闭打开天线功能，与PiccReset函数里面的_1ms的定义一致
3.ucMethod一般使用0x01
4.*pINFLen为返回卡号长度
5.*pINF为返回卡号和应答信息
--------------------------------------------------------------------------------------------------------
6.执行成功PiccActivateC返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccActivateC(	unsigned char ucMode, 
													unsigned char ucMethod,
													unsigned char *pINFLen,
													unsigned char *pINF);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccRequestATS用于ISO14443A卡片CPU类型卡请求应答，激活到ISO14443-4 T=Cl模式操作
--------------------------------------------------------------------------------------------------------
2.ucCID为卡片标识，一般给0x00或者0x01
3.*pATSLen为返回长度
4.*pATS为返回应答信息
--------------------------------------------------------------------------------------------------------
5.执行成功PiccRequestATS返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccRequestATS(unsigned char ucCID,
													unsigned char *pATSLen, 
													unsigned char *pATS);


/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccTPCL用于ISO14443A卡片CPU类型卡T=Cl APDU操作
--------------------------------------------------------------------------------------------------------
2.usSendLen为发送数据长度
3.*pSendBuf为发送的数据
4.*pRcvLen为返回数据长度
5.*pRcvBuf为返回的数据
--------------------------------------------------------------------------------------------------------
5.执行成功PiccTPCL返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccTPCL(	unsigned int usSendLen,
												unsigned char *pSendBuf, 		
												unsigned int *pRcvLen,
												unsigned char *pRcvBuf);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccTANSf用于ISO14443A卡片CPU类型卡T=Cl 原始数据发送接收，一般不用
--------------------------------------------------------------------------------------------------------
2.usSendLen为发送数据长度
3.*pSendBuf为发送的数据
4.*pRcvLen为返回数据长度
5.*pRcvBuf为返回的数据
--------------------------------------------------------------------------------------------------------
5.执行成功PiccTANSf返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccTANSf(	unsigned int usSendLen,
												unsigned char *pSendBuf, 		
												unsigned int *pRcvLen,
												unsigned char *pRcvBuf);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccAutoRATS用于ISO14443A卡片激活时是否自动获取ATS信息
--------------------------------------------------------------------------------------------------------
2.rats：使能或者禁止自动RATS功能，0为禁止，1为使能
3.*pATSLen为返回长度
4.*pATS为返回应答信息
--------------------------------------------------------------------------------------------------------
5.执行成功PiccAutoRATS返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccAutoRATS(unsigned char rats);


//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//此种卡片带密码和AES加密运算											     Mifare0 ultralight c 卡片操作
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccULAuth用于ultralight c卡片认证
--------------------------------------------------------------------------------------------------------
2.*pKey为输入的密码
--------------------------------------------------------------------------------------------------------
3.执行成功PiccULAuth返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccULAuth(unsigned char *pKey);

/*
--------------------------------------------------------------------------------------------------------
1.功能：PiccULSetKey用于ultralight c卡片密码设置/密码修改，须先做认证操作
--------------------------------------------------------------------------------------------------------
2.*pKey为输入的新密码，须先做认证操作
--------------------------------------------------------------------------------------------------------
3.执行成功PiccULSetKey返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int PiccULSetKey(unsigned char *pKey);


//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//此种卡片带密码和AES/DES/3DES加密运算			    								Mifare DESFire卡片操作
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
//请参考DESFire数据手册使用,所有字段符合DESFire数据手册
extern "C" __declspec(dllexport) int DESGetDESVersion(unsigned char *relen,unsigned char *rebuf);
//
extern "C" __declspec(dllexport) int DESAuthenticate(unsigned char KeyNO,unsigned char *pKey);
extern "C" __declspec(dllexport) int DESChangKey(unsigned char KeyNo,unsigned char KeySettings,unsigned char *pNewKey,unsigned char *pOldKey);
extern "C" __declspec(dllexport) int DESGetKeyVersion(unsigned char KeyNO,unsigned char *pKeyVersion);
extern "C" __declspec(dllexport) int DESGetKeySetting(unsigned char *pKeySetting,unsigned char *pMaxKeyNum);
extern "C" __declspec(dllexport) int DESChangKeySetting(unsigned char KeySetting);
//
extern "C" __declspec(dllexport) int DESSelectApplication(long AID);
extern "C" __declspec(dllexport) int DESGetApplicationIDs(unsigned char *pAIDs,unsigned char *pAIDno);
extern "C" __declspec(dllexport) int DESDeleteApplication(unsigned long AID);
extern "C" __declspec(dllexport) int DESFormatPicc(void);
extern "C" __declspec(dllexport) int DESCreateApplication(unsigned long AID,unsigned char KeySetting,unsigned char KeyNo);
//
extern "C" __declspec(dllexport) int DESGetFileIDs(unsigned char *pIDs,unsigned char *pFileIDs);
extern "C" __declspec(dllexport) int DESCreateStdDataFile( unsigned char FileID,unsigned char ComSet,unsigned short AccessRights,unsigned short FileSize);
extern "C" __declspec(dllexport) int DESCreateBackupDataFile( unsigned char FileID,unsigned char ComSet,unsigned short AccessRights,unsigned short FileSize);
extern "C" __declspec(dllexport) int DESCreateValueFile( unsigned char FileID,unsigned char ComSet,unsigned short AccessRights,long LowerLimit,long UpperLimit,long Value,unsigned char LimitCredit);
extern "C" __declspec(dllexport) int DESCreateLinearRecordFile( unsigned char FileID,unsigned char ComSet,unsigned short AccessRights,unsigned short FileSize,unsigned short RecordsNum);
extern "C" __declspec(dllexport) int DESCreateCyclicRecordFile( unsigned char FileID,unsigned char ComSet,unsigned short AccessRights,unsigned short FileSize,unsigned short RecordsNum);
extern "C" __declspec(dllexport) int DESDeleteDESFile(unsigned char FileID);
extern "C" __declspec(dllexport) int DESGetFileSettings(unsigned char FileID,unsigned char *pInfoLen,unsigned char *pFileInfo);
extern "C" __declspec(dllexport) int DESChangeFileSettings(unsigned char FileID,unsigned char NewComSet,unsigned short NewAccessRights);
//
extern "C" __declspec(dllexport) int DESWriteData(unsigned char FileID,unsigned short Offset,unsigned short Length,unsigned char *pBuf);
extern "C" __declspec(dllexport) int DESReadData(unsigned char FileID,unsigned short Offset,unsigned short Length,unsigned char *pBuf,unsigned short *RcvLen);
extern "C" __declspec(dllexport) int DESGetValue(unsigned char FileID,long *Value);
extern "C" __declspec(dllexport) int DESOperateValue(unsigned char FileID,unsigned char ValueCommand,long Value);
extern "C" __declspec(dllexport) int DESWriteRecord(unsigned char FileID,unsigned short Offset,unsigned short Length,unsigned char *pBuf);
extern "C" __declspec(dllexport) int DESReadRecord(unsigned char FileID,unsigned short RecordNo,unsigned short RecordNum,unsigned char *pBuf,unsigned short *RcvLen);
extern "C" __declspec(dllexport) int DESClearRecordFile(unsigned char FileID);
extern "C" __declspec(dllexport) int DESTransaction(unsigned char Command);


//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																						  ISO7816卡片操作
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
extern "C" __declspec(dllexport) int IccPowerUp(	unsigned char usCardSlot,
													unsigned char *pRecLen,
													unsigned char *pRcvBuf);
extern "C" __declspec(dllexport) int IccPowerDn(	unsigned char usCardSlot );
extern "C" __declspec(dllexport) int IccAPDU (	unsigned char usCardSlot,
												unsigned int usSendLen,
												unsigned char *pSendBuf, 		
												unsigned int *pRcvLen,
												unsigned char *pRcvBuf);
extern "C" __declspec(dllexport) int IccCheck_Pres (unsigned char usCardSlot, unsigned char *usStatus );
extern "C" __declspec(dllexport) int IccSetInitBaudrate (unsigned char usCardSlot,unsigned char ucRates );
//--------------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																						  ISO15693卡片操作
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Inventory用于作寻卡操作，目的是取得当前天线区域内的卡片卡号
--------------------------------------------------------------------------------------------------------
2.flags在寻卡时假如天线区域只有一张卡，那么flags=0x26，假如需要寻多张卡片，那么flags=0x06；
3.AFI一般使用0x00
4.masklengh一般使用0x00
5.*uid一般为空
6.*resplen为返回卡号长度，比如一张卡，那么*resplen==8，两张卡则*resplen==16
7.*resp为所存卡号，8个字节一组，顺序相接，不分先后，注意每张卡8个字节卡号的最后一个字节总是0xE0
--------------------------------------------------------------------------------------------------------
8.执行成功ISO15693_Inventory返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Inventory(unsigned char flags,
														unsigned char AFI, 
														unsigned char masklengh, 
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Select用作选择卡片，目的是多张卡片在天线区域时，后续操作只针对被选卡片，
或者把静默的卡片激活到选择状态
--------------------------------------------------------------------------------------------------------
2.flags与寻卡时不同，假如此处选择卡片必须带卡号操作，所以flag一般为0x22
3.*uid为要选择卡片的卡号
4.*resplen为返回数据长度，成功的话一般为两个字节状态数据，可以忽略
5.*resp为返回数据，成功的话一般为两个字节状态数据分别为0x00和0x00，可以忽略
--------------------------------------------------------------------------------------------------------
6.执行成功ISO15693_Select返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Select(unsigned char flags,
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Stay_Quiet用作静默卡片，目的是多张卡片在天线区域时，不让这张卡片响应一般的命令
--------------------------------------------------------------------------------------------------------
2.flags此处选择静默卡片必须带卡号操作，所以flag一般为0x22
3.*uid为要选择静默卡片的卡号
4.*resplen为返回数据长度，可以忽略
5.*resp为返回数据，可以忽略
--------------------------------------------------------------------------------------------------------
6.注意此函数执行结果一般都为1，因为卡片已经被静默，不会响应数据了
--------------------------------------------------------------------------------------------------------
注意：由于函数执行总是返回1，所以操作此函数要确保输入的flag值为0x22，*uid卡号输入正确，即可
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Stay_Quiet(unsigned char flags,
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Read_Block用作读取卡片数据区数据，一般一次读取一个块的数据为4字节，块号由0开始
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以不经过寻卡直接读取块数据flags值为0x02，此时*uid可以为空
假如读取多张卡里面某张卡片的数据则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.blnr为block number的意思，表示要操作的块号码
4.nbl为number of block 的意思，表示一次操作卡片从blnr开始算的多少个块的数据，视卡片支持，一般为0x01
5.*uid为要选择读取数据的卡片的卡号
6.*resplen为返回数据长度，当读取一个块时，一般为6，其中前两个字节为状态字节，可以忽略，后面4字节为数据
7.*resp为返回数据，一般前两个字节为0x00，0x00，后面四个字节为块数据
--------------------------------------------------------------------------------------------------------
8.执行成功ISO15693_Read_Block返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Read_Block(unsigned char flags,
														unsigned char blnr, 
														unsigned char nbl, 
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Write_Block用作读取卡片数据区数据，一般一次读取一个块的数据为4字节，块号由0开始
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以不经过寻卡直接读取块数据flags值为0x02，此时*uid可以为空
假如读取多张卡里面某张卡片的数据则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.blnr为block number的意思，表示要操作的块号码
4.nbl为number of block 的意思，表示一次操作卡片从blnr开始算的多少个块的数据，视卡片支持，一般为0x01
5.*uid为要选择读取数据的卡片的卡号
6.*resplen为返回数据长度，一般为0x02，可以忽略
7.*resp为返回数据，可以忽略
--------------------------------------------------------------------------------------------------------
8.执行成功ISO15693_Write_Block返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Write_Block(unsigned char flags,
														unsigned char blnr, 
														unsigned char nbl, 
														unsigned char *uid, 
														unsigned char *dtw, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Lock_Block用作锁定数据块，被锁的块只能读取不能再写入
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以不经过寻卡直接锁定，flags值为0x02，此时*uid可以为空；假如读取多张卡里面
某张卡片的数据则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号，建议带卡号操作
3.blnr为block number的意思，表示要操作的块号码
4.*uid为要选择读取数据的卡片的卡号
5.*resplen为返回数据长度，一般为0x02
6.*resp为返回数据，没被锁的卡片一般返回0x00，0x00，已经被锁的卡片会返回0x00，0x01，即第二字节为0x01
--------------------------------------------------------------------------------------------------------
7.执行成功ISO15693_Lock_Block返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Lock_Block(unsigned char flags,
														unsigned char blnr, 
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Write_AFI用作写入AFI（Application Family Identifier ）应用族
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以直接操作，flags值为0x02，此时*uid可以为空；假如操作多张卡里面
某张卡片的时候则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.AFI为要写入的一个字节Application Family Identifier数据
4.*uid为要选择读取数据的卡片的卡号
5.*resplen为返回数据长度，一般为0x02
6.*resp为返回数据，没被锁AFI的卡片一般返回0x00，0x00，已经被锁AFI的卡片会返回0x00，0x01，即第二字节为0x01
--------------------------------------------------------------------------------------------------------
7.执行成功ISO15693_Write_AFI返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Write_AFI(unsigned char flags,
														unsigned char AFI, 
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Lock_AFI用作锁定之前写入的AFI（Application Family Identifier ）
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以直接操作，flags值为0x02，此时*uid可以为空；假如操作多张卡里面
某张卡片的时候则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.*uid为要选择读取数据的卡片的卡号
4.*resplen为返回数据长度，一般为0x02
5.*resp为返回数据，没被锁AFI的卡片一般返回0x00，0x00，已经被锁AFI的卡片会返回0x00，0x01，即第二字节为0x01
--------------------------------------------------------------------------------------------------------
6.执行成功ISO15693_Lock_AFI返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Lock_AFI(unsigned char flags,
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Write_DSFID用作写入DSFID（Data Storage Format Identifier）数据存储格式标识
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以直接操作，flags值为0x02，此时*uid可以为空；假如操作多张卡里面
某张卡片的时候则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.DSFID为要写入的一个字节Data Storage Format Identifier数据
4.*uid为要选择读取数据的卡片的卡号
5.*resplen为返回数据长度，一般为0x02
6.*resp为返回数据，没被锁AFI的卡片一般返回0x00，0x00，已经被锁DSFID的卡片会返回0x00，0x01
--------------------------------------------------------------------------------------------------------
7.执行成功ISO15693_Write_DSFID返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Write_DSFID(unsigned char flags,
														unsigned char DSFID, 
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Lock_DSFID用作锁定之前写入的DSFID（Data Storage Format Identifier）
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以直接操作，flags值为0x02，此时*uid可以为空；假如操作多张卡里面
某张卡片的时候则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.*uid为要选择读取数据的卡片的卡号
4.*resplen为返回数据长度，一般为0x02
5.*resp为返回数据，没被锁AFI的卡片一般返回0x00，0x00，已经被锁DSFID的卡片会返回0x00，0x01
--------------------------------------------------------------------------------------------------------
6.执行成功ISO15693_Lock_DSFID返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Lock_DSFID(unsigned char flags,
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);

/*
--------------------------------------------------------------------------------------------------------
1.功能：ISO15693_Get_SysInfor用作获取卡片信息，比如AFI，DSFID的读取，卡片容量，还有卡片厂家信息，
--------------------------------------------------------------------------------------------------------
2.flags当天线区域只有一张卡片时可以直接操作，flags值为0x02，此时*uid可以为空；假如操作多张卡里面
某张卡片的时候则flags一般为0x22，表示附带卡号操作卡片，此时*uid必须输入卡号
3.*uid为要选择读取数据的卡片的卡号
4.*resplen为返回数据长度，一般为0x10
5.*resp为返回数据，数据依次为：
2个字节一般为0x00，0x00，表示状态，
1个字节卡片信息，一般为0x0F不使用，
8个字节卡号
1个字节DSFID
1个字节AFI
2个字节卡片容量，一般低字节在前
1个字节厂家参考信息
--------------------------------------------------------------------------------------------------------
6.执行成功ISO15693_Get_SysInfor返回0，失败则为其它
--------------------------------------------------------------------------------------------------------
*/
extern "C" __declspec(dllexport) int ISO15693_Get_SysInfor(unsigned char flags,
														unsigned char *uid, 
														unsigned short *resplen, 
														unsigned char *resp);




//--------------------------------------------------------------------------------------------------------
//********************************************************************************************************
//																									   END
//********************************************************************************************************
//--------------------------------------------------------------------------------------------------------
//
#endif